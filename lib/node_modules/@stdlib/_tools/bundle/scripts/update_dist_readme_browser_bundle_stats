#!/usr/bin/env node

/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/**
* Script to update the README documenting distributable files with current browser bundle stats.
*
* ## Usage
*
* ```bash
* $ DEBUG=* node /path/to/bundle/update_dist_readme_browser_bundle_stats
* ```
*
*
* @private
*/
'use strict';

// MODULES //

var resolve = require( 'path' ).resolve;
var join = require( 'path' ).join;
var lstat = require( 'fs' ).lstatSync; // eslint-disable-line no-sync
var logger = require( 'debug' );
var remark = require( 'remark' );
var visit = require( 'unist-util-visit' );
var readFile = require( '@stdlib/fs/read-file' ).sync;
var writeFile = require( '@stdlib/fs/write-file' ).sync;
var roundn = require( '@stdlib/math/base/special/roundn' );


// VARIABLES //

var debug = logger( 'bundle:update-dist-readme-browser-bundle-stats' );

// WARNING: fragile, as this may need to be updated if script is moved...
var dir = resolve( __dirname, '..', '..', '..', '..', '..', '..', 'dist' );
var fpath = join( dir, 'README.md' );

// Regular expressions for identifying where to include bundle stats:
var RE_START = /<!-- <bundle-stats.*> -->/;
var RE_END = /<!-- <\/bundle-stats> -->/;
var FILES = /files="([^"]*)"/;


// FUNCTIONS //

/**
* Converts a number of bytes to a human readable string.
*
* @private
* @param {number} bytes - number of bytes
* @returns {string} human readable string
*/
function bytes2str( bytes ) {
	if ( bytes/1.0e6 > 1.0 ) {
		return roundn( bytes/1.0e6, -3 ) + ' MB';
	}
	return roundn( bytes/1.0e3, -3 ) + ' kB';
}

/**
* Attaches a plugin to a remark processor in order to insert bundle stats.
*
* @private
* @returns {Function} transformer
*/
function attacher() {
	return transformer;

	/**
	* Transforms a Markdown abstract syntax tree (AST).
	*
	* @private
	* @param {Node} tree - root AST node
	*/
	function transformer( tree ) {
		debug( 'Processing virtual file...' );
		visit( tree, 'html', visitor );
	}

	/**
	* Inserts bundle stats into a Markdown AST.
	*
	* @private
	* @param {Node} node - reference node
	* @param {number} index - position of `node` in `parent`
	* @param {Node} parent - parent of `node`
	* @throws {Error} bundle stats comments must have a valid `files` attribute
	* @throws {Error} bundle stats comments must have starting and ending comments
	*/
	function visitor( node, index, parent ) {
		var tableHeader;
		var tableRow;
		var nbytes;
		var stats;
		var files;
		var table;
		var len;
		var i;

		if ( RE_START.test( node.value ) === true ) {
			debug( 'Found a bundle stats element...' );

			files = FILES.exec( node.value );
			if ( files === null ) {
				debug( 'Invalid node: %s', node.value );
				throw new Error( 'invalid node. Bundle stats comments must have a valid `files` attribute. Node: '+node.value+'.' );
			}
			files = files[ 1 ];
			debug( 'Files: %s', files );
			files = files.split( ',' );
			len = files.length;
			if ( len === 0 ) {
				debug( 'Bundle stats element does not list any files. Skipping...' );
				return;
			}

			debug( 'Computing bundle stats for %d files...', len );
			stats = new Array( len );
			for ( i = 0; i < len; i++ ) {
				nbytes = lstat( join( dir, files[ i ] ) ).size;
				stats[ i ] = bytes2str( nbytes );
				debug( 'File: %s. Size: %s.', files[ i ], stats[ i ] );
			}

			debug( 'Generating table header...' );
			tableHeader = {
				'type': 'tableHeader',
				'children': []
			};
			for ( i = 0; i < len; i++ ) {
				tableHeader.children.push({
					'type': 'tableCell',
					'children': [
						{
							'type': 'text',
							'value': files[ i ]
						}
					]
				});
			}

			debug( 'Generating table row...' );
			tableRow = {
				'type': 'tableRow',
				'children': []
			};
			for ( i = 0; i < len; i++ ) {
				tableRow.children.push({
					'type': 'tableCell',
					'children': [
						{
							'type': 'text',
							'value': stats[ i ]
						}
					]
				});
			}

			debug( 'Generating table...' );
			table = {
				'type': 'table',
				'children': [ tableHeader, tableRow ]
			};

			debug( 'Inserting table into Markdown AST...' );

			// Case 1: insert new node between comment tags...
			if ( RE_END.test( parent.children[ index+1 ].value ) ) {
				debug( 'Inserting new node...' );
				parent.children.splice( index+1, 0, table );
			}
			// Case 2: replace existing node...
			else if ( RE_END.test( parent.children[ index+2 ].value ) ) {
				debug( 'Replacing existing node...' );
				parent.children[ index+1 ] = table;
			}
			else {
				debug( 'Invalid node: %s', node.value );
				throw new Error( 'invalid node. Invalid bundle stats comment. Ensure that the Markdown file includes both starting and ending bundle stats comments. Node: `' + node.value + '`.' );
			}
			debug( 'Finished processing bundle stats element.' );
		}
	}
}


// MAIN //

/**
* Main execution sequence.
*
* @private
*/
function main() {
	var file;
	var opts;

	opts = {
		'encoding': 'utf8'
	};

	debug( 'Reading README file...' );
	file = readFile( fpath, opts );

	debug( 'Processing file...' );
	file = remark().use( attacher ).processSync( file );

	debug( 'Writing file...' );
	writeFile( fpath, file.contents, opts );
	debug( 'Finished processing file.' );
}

main();
