/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var logger = require( 'debug' );
var parseHeader = require( 'parse-link-header' );
var hasOwnProp = require( '@stdlib/assert/has-own-property' );
var request = require( './request.js' );
var flatten = require( './flatten.js' );
var getOptions = require( './options.js' );
var urlpath = require( './path.js' );
var lastPage = require( './lastpage.js' );
var getTotal = require( './total.js' );
var createCache = require( './cache.js' );
var getRateLimit = require( './ratelimit.js' );
var checkRateLimit = require( './checklimit.js' );


// VARIABLES //

var debug = logger( 'github-get:resolve' );


// MAIN //

/**
* Resolves endpoint resources.
*
* @private
* @param {Options} opts - request options
* @param {Callback} clbk - callback to invoke after resolving resources
*/
function resolve( opts, clbk ) {
	var ratelimit;
	var options;
	var count;
	var total;
	var data;
	var last;
	var err;

	options = getOptions( opts ); // request options

	count = 0;
	total = 1;
	last = 1;

	debug( 'Beginning request.' );
	getPage( opts.page );

	/**
	* Gets a single resource page.
	*
	* @private
	* @param {PositiveInteger} i - page number
	*/
	function getPage( i ) {
		options.path = urlpath({
			'pathname': opts.pathname,
			'page': i,
			'per_page': opts.per_page,
			'query': opts.query
		});
		debug( 'Request path: %s', options.path );

		debug( 'Attempting to resolve page %d.', i );
		request( options, onPage );
	}

	/**
	* Gets multiple resource pages.
	*
	* @private
	* @param {PositiveInteger} i - start page
	* @param {PositiveInteger} j - end page
	*/
	function getPages( i, j ) {
		for ( ; i <= j; i++ ) {
			getPage( i );
		}
	}

	/**
	* Callback invoked upon receiving an HTTP response.
	*
	* @private
	* @param {(Error|null)} error - error or null
	* @param {Object} response - HTTP response object
	* @param {(ObjectArray|Object)} body - response body
	* @returns {void}
	*/
	function onPage( error, response, body ) {
		var link;
		var curr;

		count += 1;
		debug( '%d of %d pages resolved.', count, total );

		if ( arguments.length === 1 ) {
			debug( 'No available rate limit information.' );
			return done( error );
		}
		// If this is the first response, get initial rate limit info; otherwise, update rate limit info...
		if ( count === 1 ) {
			ratelimit = getRateLimit( response.headers );
		} else {
			ratelimit = checkRateLimit( ratelimit, response.headers );
		}
		if ( error ) {
			return done( error );
		}
		// If a user wants multiple pages, we need to parse the link header...
		if (
			opts.last_page > opts.page ||
			opts.last_page === 'last'
		) {
			debug( 'Attempting to parse link header: %s', response.headers.link );
			link = parseHeader( response.headers.link );
		}
		// Handle two cases: 1) user does not want multiple pages; 2) only one page exists (no link header => link=null)...
		if (
			link === void 0 || // single page
			link === null      // no link header
		) {
			debug( 'Single page request.' );
			data = body;
			return done();
		}
		// If we have a link header, we have a paginated response...
		debug( 'Parsed link header: %s', JSON.stringify( link ) );

		if ( data === void 0 ) {
			last = lastPage( opts.last_page, +link.last.page );
			debug( 'Last page to resolve: %d.', last );

			total = getTotal( opts.page, last );
			debug( 'Total number of pages to resolve: %d.', total );

			data = createCache( total );
			debug( 'Initialized response cache of size: %d.', total );
		}
		if ( hasOwnProp( link, 'next' ) ) {
			curr = +link.next.page - 1;
		} else {
			curr = +link.prev.page + 1;
		}
		debug( 'Current page: %d.', curr );

		debug( 'Caching page results.' );
		data[ curr-1 ] = body;

		if ( curr === opts.page ) {
			debug( 'First paginated result. Resolving %d remaining page(s).', total-count );
			setTimeout( getNext( curr+1, last ), 0 ); // dezalgo'd
		}
		done();
	}

	/**
	* Returns a function to resolve the next pages.
	*
	* @private
	* @param {PositiveInteger} i - start page
	* @param {PositiveInteger} j - end page
	* @returns {Function} function to resolve next pages
	*/
	function getNext( i, j ) {
		return next;

		/**
		* Resolves the next set of pages.
		*
		* @private
		*/
		function next() {
			getPages( i, j );
		}
	}

	/**
	* Callback invoked upon resolving resources.
	*
	* @private
	* @param {Error} [error] - error object
	* @returns {void}
	*/
	function done( error ) {
		if ( error && !err ) {
			err = error;
		}
		if ( count === total ) {
			debug( 'Request completed.' );
			if ( err ) {
				if ( ratelimit ) {
					return clbk( err, null, ratelimit );
				}
				return clbk( err );
			}
			if ( total > 1 ) {
				debug( 'Flattening paginated results.' );
				data = flatten( data );
				debug( 'Total number of results: %d', data.length );
			}
			return clbk( null, data, ratelimit );
		}
	}
}


// EXPORTS //

module.exports = resolve;
