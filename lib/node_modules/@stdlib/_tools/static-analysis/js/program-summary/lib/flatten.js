/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var walk = require( 'acorn-walk' ).fullAncestor;
var contains = require( '@stdlib/assert/contains' );
var types = require( './node_types.js' );


// MAIN //

/**
* Flattens an AST.
*
* @private
* @param {Node} ast - AST node
* @param {NonNegativeInteger} scope - scope level
* @param {NonNegativeInteger} depth - nesting depth
* @returns {Array} flattened AST
*/
function flatten( ast, scope, depth ) {
	var out = [];
	walk( ast, visit );
	return out;

	/**
	* Callback invoked upon visiting an AST node.
	*
	* @private
	* @param {Node} node - AST node
	* @param {*} state - state
	* @param {Array<Node>} ancestors - ancestor nodes
	*/
	function visit( node, state, ancestors ) {
		var level;
		var type;
		var d;
		var i;
		if ( node !== ast && contains( types, node.type ) ) {
			level = scope;
			d = depth;
			for ( i = 0; i < ancestors.length-1; i++ ) {
				type = ancestors[ i ].type;
				if (
					type === 'FunctionDeclaration' ||
					type === 'FunctionExpression'
				) {
					level += 1;
				} else if (
					type === 'BlockStatement'
				) {
					d += 1;
				}
			}
			node.__scope__ = level; // eslint-disable-line no-underscore-dangle
			node.__depth__ = d; // eslint-disable-line no-underscore-dangle
			out.push( node );
		}
	}
}


// EXPORTS //

module.exports = flatten;
