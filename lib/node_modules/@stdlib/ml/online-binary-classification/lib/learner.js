/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

/* eslint-disable */ // TODO: fix me
'use strict';

// MODULES //

var isString = require( '@stdlib/assert/is-string' ).isPrimitive;
var isArray = require( '@stdlib/assert/is-array' );
var copy = require( '@stdlib/utils/copy' );
var defineProperty = require( '@stdlib/utils/define-property' );
var exp = require( '@stdlib/math/base/special/exp' );
var modifiedHuberLoss = require( './loss/modified_huber.js' );
var squaredHingeLoss = require( './loss/squared_hinge.js' );
var WeightVector = require( './weight_vector.js' );
var perceptron = require( './loss/perceptron.js' );
var hingeLoss = require( './loss/hinge.js' );
var logLoss = require( './loss/log.js' );
var getEta = require( './eta_factory.js' );
var DEFAULTS = require( './defaults.json' );
var validate = require( './validate.js' );


// MAIN //

/**
* Online learning for classification using stochastic gradient descent (SGD).
*
* ## Method
*
* The sub-gradient of the loss function is estimated for each datum and the classification model is updated incrementally, with a decreasing learning rate and regularization of the feature weights based on L2 regularization.
*
* ## References
*
* -   Shalev-Shwartz, S., Singer, Y., Srebro, N., & Cotter, A. (2011). Pegasos: Primal estimated sub-gradient solver for SVM. Mathematical Programming, 127(1), 3â€“30. doi:10.1007/s10107-010-0420-4
*
* @param {Object} [options] - options object
* @param {PositiveNumber} [options.epsilon=0.1] - insensitivity parameter
* @param {PositiveNumber} [options.eta0=0.02] - constant learning rate
* @param {PositiveNumber} [options.lambda=1e-3] - regularization parameter
* @param {string} [options.learningRate='basic'] - string denoting the learning rate to use. Can be `constant`, `pegasos` or `basic`.
* @param {string} [options.loss='log'] - string denoting the loss function to use. Can be `leastSquares`, `epsilonInsensitive` or `huber`.
* @param {boolean} [options.intercept=true] - boolean indicating whether to include an intercept
* @throws {TypeError} must provide valid options
* @returns {Object} classification model
*
* @example
* var SGDClassificationModel = require( '@stdlib/streams/ml/online-sgd-classification' );
*
* var model = SGDClassificationModel({
*    'intercept': true
*    'lambda': 1e-5
* });
*
* // Update model as observations come in:
* var y = 3.5;
* var x = [ 2.3, 1.0, 5.0 ];
* model.update( x, y );
*
* // Predict new observation:
* var yHat = model.predict( x );
*
* // Retrieve coefficients:
* var coefs = model.coefs;
*/
function SGDClassificationModel( options ) {
	var _nFeatures;
	var _lossfun;
	var _weights;
	var _getEta;
	var model;
	var opts;
	var err;
	var _it;

	opts = copy( DEFAULTS );
	if ( arguments.length > 0 ) {
		err = validate( opts, options );
		if ( err ) {
			throw err;
		}
	}
	_weights = null;
	// Initialize counter:
	_it = 1;

	// Set loss function depending on chosen model:
	switch ( opts.loss ) {
	case 'log':
		_lossfun = logLoss;
	break;
	case 'hinge':
		_lossfun = hingeLoss;
	break;
	case 'modifiedHuber':
		_lossfun = modifiedHuberLoss;
	break;
	case 'perceptron':
		_lossfun = perceptron;
	break;
	case 'squaredHinge':
		_lossfun = squaredHingeLoss;
	break;
	default:
		throw Error( 'invalid input value. `loss` option must be either `hinge`, `log`, `modifiedHuber`, `perceptron` or `squaredHinge`. Value: `' + opts.loss + '`' );
	}

	// Set learning rate:
	_getEta = getEta( opts.learningRate, opts.eta0, opts.lambda );

	/**
	* SGD classification model.
	*
	* @namespace SGDClassificationModel
	*/
	model = {};

	// Define coefficient getter:

	/**
	*  Model coefficients / feature weights.
	*
	* @name coefs
	* @memberof SGDClassificationModel
	* @type {Array}
	*
	* @example
	* // Retrieve coefficients:
	* var coefs = model.coefs;
	*/
	defineProperty( model, 'coefs', {
		'get': function getCoefs() {
			var ret;
			var i;

			ret = new Array( _weights.nWeights );
			for ( i = 0; i < ret.length; i++ ) {
				ret[ i ] = _weights._data[ i ] * _weights.scale;
			}
			return ret;
		},
		'configurable': false,
		'enumerable': false
	});

	/**
	* Update weights given new observations `y` and `x`.
	*
	* @name update
	* @memberof SGDClassificationModel
	* @type {Function}
	* @param {NumericArray} x - feature vector
	* @param {number} y - response value
	*
	* @example
	* // Update model as observations come in:
	* var y = 1;
	* var x = [ 2.3, 1.0, 5.0 ];
	* model.update( x, y );
	*/
	model.update = function update( x, y ) {
		var eta;

		if ( !_weights ) {
			_weights = new WeightVector( x.length, opts.intercept );
			_nFeatures = opts.intercept ? _weights.nWeights - 1 : _weights.nWeights;
		}

		if ( !isArray( x ) || x.length !== _nFeatures ) {
			throw new TypeError( 'invalid input value. First argument `x` must be an array of length ' + this.nFeatures + '. Value: `' + x + '`' );
		}
		if ( y !== -1 && y !== 1 ) {
			throw new TypeError( 'invalid input value. Second argument `y` must be +1 or -1. Value: `' + y + '`' );
		}

		// Get current learning rate...
		eta = _getEta();

		// Update weights depending on the chosen loss function...
		_lossfun( _weights, x, y, eta, opts.lambda );
	}; // end METHOD _updateWithoutIntercept()

	/**
	* Predict response for a new observation with features `x`.
	*
	* @name predict
	* @memberof SGDClassificationModel
	* @type {Function}
	* @param {NumericArray} x - feature vector
	* @param {string} [type="link"] - `probability` or `link`
	* @returns {number} response value
	*
	* @example
	* // Predict new observation:
	* var x = [ 2.3, 5.3, 8.6 ];
	* var yHat = model.predict( x );
	*/
	model.predict = function predict( x, type ) {
		var wx;
		if ( !isArray( x ) || x.length !== _nFeatures ) {
			throw new TypeError( 'invalid input value. First argument `x` must be an array of length ' + this.nFeatures + '. Value: `' + x + '`' );
		}
		if ( arguments.length > 1 ) {
			if ( !isString( type ) || ( type !== 'link' && type !== 'probability' ) ) {
				throw new TypeError( 'invalid input value. Second argument `type` must be `probability` or `link`. Value: `' + x + '`' );
			}
		}
		wx = _weights.innerProduct( x );
		if ( type !== 'probability' ) {
			return wx;
		}
		// Case: type === 'probability'
		if ( _lossfun !== logLoss && _lossfun !== modifiedHuberLoss ) {
			throw new Error( 'probability predictions are only supported when `loss` is `log` or `modifiedHuber`. Value: `' + type + '`' );
		}

		return 1.0 / ( 1.0 + exp( -wx ) );
	}; // end METHOD predict()

	return model;
}


// EXPORTS //

module.exports = SGDClassificationModel;
