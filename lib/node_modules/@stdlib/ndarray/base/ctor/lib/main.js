/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var setReadOnly = require( '@stdlib/utils/define-nonenumerable-read-only-property' );
var setReadOnlyAccessor = require( '@stdlib/utils/define-nonenumerable-read-only-accessor' );
var bytesPerElement = require( '@stdlib/ndarray/base/bytes-per-element' );
var iterationOrder = require( '@stdlib/ndarray/base/iteration-order' );
var strides2order = require( '@stdlib/ndarray/base/strides2order' );
var isColumnMajorContiguous = require( './is_column_major_contiguous.js' );
var isRowMajorContiguous = require( './is_row_major_contiguous.js' );
var isContiguous = require( './is_contiguous.js' );
var copyFlags = require( './copy_flags.js' );
var compileSet = require( './compile_set.js' );
var compileGet = require( './compile_get.js' );
var igetValue = require( './iget.js' );
var isetValue = require( './iset.js' );
var setValue = require( './set.js' );
var getValue = require( './get.js' );
var toJSON = require( './tojson.js' );
var toString = require( './tostring.js' ); // eslint-disable-line stdlib/no-redeclare
var defaults = require( './defaults.json' );


// MAIN //

/**
* Returns an ndarray constructor.
*
* @param {string} dtype - data type
* @param {PositiveInteger} ndims - number of dimensions
* @param {Options} [options] - function options
* @param {boolean} [options.codegen=true] - boolean indicating whether to use code generation
* @returns {Function} ndarray constructor
*
* @example
* var ndarray = ctor( 'float64', 3 );
* // returns <Function>
*
* var buffer = [ 1, 2, 3, 4, 5, 6 ];
* var shape = [ 3, 2 ];
* var strides = [ 2, 1 ];
* var offset = 0;
*
* var out = ndarray( buffer, shape, strides, offset, 'row-major' );
*/
function ctor( dtype, ndims, options ) {
	/* eslint-disable no-restricted-syntax */
	var opts = {};
	if ( arguments.length > 2 ) {
		opts.codegen = ( options.codegen === void 0 ) ? defaults.codegen : options.codegen; // eslint-disable-line max-len
	} else {
		opts.codegen = defaults.codegen;
	}

	/**
	* ndarray constructor.
	*
	* @private
	* @constructor
	* @param {(ArrayLikeObject|TypedArray|Buffer)} buffer - data buffer
	* @param {NonNegativeIntegerArray} shape - array shape
	* @param {IntegerArray} strides - array strides
	* @param {NonNegativeInteger} offset - index offset
	* @param {string} order - specifies whether an array is row-major (C-style) or column-major (Fortran-style)
	* @returns {ndarray} ndarray instance
	*/
	function ndarray( buffer, shape, strides, offset, order ) {
		/* eslint-disable no-invalid-this */
		var contiguous;
		var nbytes;
		var ord;
		var len;
		var i;
		if ( !(this instanceof ndarray) ) {
			return new ndarray( buffer, shape, strides, offset, order );
		}
		// Compute the number of elements...
		len = 1;
		for ( i = 0; i < ndims; i++ ) {
			len *= shape[ i ];
		}
		// Compute the number of bytes...
		if ( ndarray.BYTES_PER_ELEMENT ) {
			nbytes = ndarray.BYTES_PER_ELEMENT * len;
		} else {
			nbytes = null;
		}
		// Set private properties...
		this._byteLength = nbytes;
		this._buffer = buffer;
		this._length = len;
		this._offset = offset;
		this._order = order;
		this._shape = shape;
		this._strides = strides;

		this._iterationOrder = iterationOrder( strides );

		// Determine if the array can be stored contiguously:
		contiguous = isContiguous( len, shape, strides, offset, this._iterationOrder ); // eslint-disable-line max-len

		// Infer the array "order" from the stride array (this is supplementary to the `order` parameter):
		ord = strides2order( strides );

		this._flags = {
			'ROW_MAJOR_CONTIGUOUS': isRowMajorContiguous( ord, contiguous ),
			'COLUMN_MAJOR_CONTIGUOUS': isColumnMajorContiguous( ord, contiguous )
		};

		return this;
	}

	/**
	* Size (in bytes) of each array element (if known).
	*
	* @private
	* @name BYTES_PER_ELEMENT
	* @memberof ndarray
	* @type {(PositiveInteger|null)}
	*
	* @example
	* var nbytes = ndarray.BYTES_PER_ELEMENT;
	* // returns <number>
	*/
	setReadOnly( ndarray, 'BYTES_PER_ELEMENT', bytesPerElement( dtype ) );

	/**
	* Underlying data type.
	*
	* @private
	* @name dtype
	* @memberof ndarray
	* @type {string}
	*
	* @example
	* var dtype = ndarray.dtype;
	* // returns <string>
	*/
	setReadOnly( ndarray, 'dtype', dtype );

	/**
	* Number of dimensions.
	*
	* @private
	* @name ndims
	* @memberof ndarray
	* @type {PositiveInteger}
	*
	* @example
	* var ndims = ndarray.ndims;
	* // returns <number>
	*/
	setReadOnly( ndarray, 'ndims', ndims );

	/**
	* Size (in bytes) of the array (if known).
	*
	* @private
	* @name byteLength
	* @memberof ndarray.prototype
	* @type {(NonNegativeInteger|null)}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var byteLength = x.byteLength;
	* // returns <number>
	*/
	setReadOnlyAccessor( ndarray.prototype, 'byteLength', function get() {
		return this._byteLength;
	});

	/**
	* Size (in bytes) of each array element (if known).
	*
	* @private
	* @name BYTES_PER_ELEMENT
	* @memberof ndarray.prototype
	* @type {(PositiveInteger|null)}
	*
	* @example
	* var Float64Array = require( '@stdlib/array/float64' );
	*
	* var buffer = new Float64Array( [ 1, 2, 3, 4, 5, 6 ] );
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var nbytes = x.BYTES_PER_ELEMENT;
	* // returns 8
	*/
	setReadOnly( ndarray.prototype, 'BYTES_PER_ELEMENT', ndarray.BYTES_PER_ELEMENT );

	/**
	* Pointer to the underlying data buffer.
	*
	* @private
	* @name data
	* @memberof ndarray.prototype
	* @type {(Array|TypedArray|Buffer)}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var data = x.data;
	* // returns [ 1, 2, 3, 4, 5, 6 ]
	*/
	setReadOnlyAccessor( ndarray.prototype, 'data', function get() {
		return this._buffer;
	});

	/**
	* Underlying data type.
	*
	* @private
	* @name dtype
	* @memberof ndarray.prototype
	* @type {string}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var dtype = x.dtype;
	* // returns <string>
	*/
	setReadOnly( ndarray.prototype, 'dtype', ndarray.dtype );

	/**
	* Information about the memory layout of the array.
	*
	* @private
	* @name flags
	* @memberof ndarray.prototype
	* @type {Object}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var flgs = x.flags;
	* // returns <Object>
	*/
	setReadOnlyAccessor( ndarray.prototype, 'flags', function get() {
		return copyFlags( this._flags );
	});

	/**
	* Length of the array.
	*
	* @private
	* @name length
	* @memberof ndarray.prototype
	* @type {NonNegativeInteger}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var len = x.length;
	* // returns 6
	*/
	setReadOnlyAccessor( ndarray.prototype, 'length', function get() {
		return this._length;
	});

	/**
	* Number of dimensions.
	*
	* @private
	* @name ndims
	* @memberof ndarray.prototype
	* @type {PositiveInteger}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var ndims = x.ndims;
	* // returns <number>
	*/
	setReadOnly( ndarray.prototype, 'ndims', ndims );

	/**
	* Index offset which specifies the buffer index at which to start iterating over array elements.
	*
	* @private
	* @name offset
	* @memberof ndarray.prototype
	* @type {NonNegativeInteger}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var o = x.offset;
	* // returns 0
	*/
	setReadOnlyAccessor( ndarray.prototype, 'offset', function get() {
		return this._offset;
	});

	/**
	* Array order.
	*
	* ## Notes
	*
	* -   The array order is either row-major (C-style) or column-major (Fortran-style).
	*
	*
	* @private
	* @name order
	* @memberof ndarray.prototype
	* @type {string}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var order = x.order;
	* // returns 'row-major'
	*/
	setReadOnlyAccessor( ndarray.prototype, 'order', function get() {
		return this._order;
	});

	/**
	* Shape of the array.
	*
	* @private
	* @name shape
	* @memberof ndarray.prototype
	* @type {NonNegativeIntegerArray}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var s = x.shape;
	* // returns [ 3, 2 ]
	*/
	setReadOnlyAccessor( ndarray.prototype, 'shape', function get() {
		return this._shape.slice();
	});

	/**
	* Index strides which specify how to access data along corresponding array dimensions.
	*
	* @private
	* @name strides
	* @memberof ndarray.prototype
	* @type {IntegerArray}
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var s = x.strides;
	* // returns [ 2, 1 ]
	*/
	setReadOnlyAccessor( ndarray.prototype, 'strides', function get() {
		return this._strides.slice();
	});

	/**
	* Returns an array element.
	*
	* @private
	* @name get
	* @memberof ndarray.prototype
	* @type {Function}
	* @param {...integer} idx - indices
	* @returns {*} array element
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var v = x.get( 1, 1 );
	* // returns 4
	*/
	setReadOnly( ndarray.prototype, 'get', ( opts.codegen ) ? compileGet( ndims ) : getValue );

	/**
	* Returns an array element located at a specified linear index.
	*
	* @private
	* @name iget
	* @memberof ndarray.prototype
	* @type {Function}
	* @param {integer} idx - linear index
	* @returns {*} array element
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var v = x.iget( 3 );
	* // returns 4
	*/
	setReadOnly( ndarray.prototype, 'iget', igetValue );

	/**
	* Sets an array element.
	*
	* @private
	* @name set
	* @memberof ndarray.prototype
	* @type {Function}
	* @param {...integer} idx - indices
	* @param {*} v - value to set
	* @returns {ndarray} ndarray instance
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var v = x.get( 1, 1 );
	* // returns 4
	*
	* x.set( 1, 1, 10 );
	*
	* var b = x.data;
	* // returns [ 1, 2, 3, 10, 5, 6 ]
	*
	* v = x.get( 1, 1 );
	* // returns 10
	*/
	setReadOnly( ndarray.prototype, 'set', ( opts.codegen ) ? compileSet( ndims ) : setValue );

	/**
	* Sets an array element located at a specified linear index.
	*
	* @private
	* @name iset
	* @memberof ndarray.prototype
	* @type {Function}
	* @param {integer} idx - linear index
	* @param {*} v - value to set
	* @returns {ndarray} ndarray instance
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 0;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var v = x.iget( 3 );
	* // returns 4
	*
	* x.iset( 3, 10 );
	*
	* var b = x.data;
	* // returns [ 1, 2, 3, 10, 5, 6 ]
	*
	* v = x.iget( 3 );
	* // returns 10
	*/
	setReadOnly( ndarray.prototype, 'iset', isetValue );

	/**
	* Serializes an ndarray as a string.
	*
	* ## Notes
	*
	* -   The method does **not** serialize data outside of the buffer region defined by the array configuration.
	*
	*
	* @private
	* @name toString
	* @memberof ndarray.prototype
	* @type {Function}
	* @returns {string} serialized ndarray
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6, 7, 8 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 2;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var str = x.toString();
	* // e.g., returns 'ndarray( [ 3, 4, 5, 6, 7, 8 ], [ 3, 2 ], [ 2, 1 ], 0, "row-major" )'
	*/
	setReadOnly( ndarray.prototype, 'toString', toString );

	/**
	* Serializes an ndarray as a JSON object.
	*
	* ## Notes
	*
	* -   `JSON.stringify()` implicitly calls this method when stringifying an `ndarray` instance.
	* -   The method does **not** serialize data outside of the buffer region defined by the array configuration.
	*
	*
	* @private
	* @name toJSON
	* @memberof ndarray.prototype
	* @type {Function}
	* @returns {Object} serialized ndarray
	*
	* @example
	* var buffer = [ 1, 2, 3, 4, 5, 6, 7, 8 ];
	* var shape = [ 3, 2 ];
	* var strides = [ 2, 1 ];
	* var offset = 2;
	*
	* var x = ndarray( buffer, shape, strides, offset, 'row-major' );
	*
	* var o = x.toJSON();
	* // e.g., returns { 'type': 'ndarray', 'dtype': '<dtype>', 'flags': {...}, 'offset': 0, 'order': 'row-major', 'shape': [ 3, 2 ], 'strides': [ 2, 1 ], 'data': [ 3, 4, 5, 6, 7, 8 ] }
	*/
	setReadOnly( ndarray.prototype, 'toJSON', toJSON );

	return ndarray;
}


// EXPORTS //

module.exports = ctor;
