/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var objectKeys = require( '@stdlib/utils/keys' );
var setReadOnly = require( '@stdlib/utils/define-nonenumerable-read-only-property' );
var Uint8Array = require( '@stdlib/array/uint8' );


// MAIN //

/**
* Returns a JavaScript wrapper for a C function.
*
* @private
* @param {Module} Module - Module
* @returns {Function} wrapper
*/
function cwrap( Module ) {
	var wrapper;
	var CACHE;
	var LIMIT;
	var COUNT;

	// Rather than an allocate a chunk of memory (e.g., via an array), assume a sparse data structure for the heap cache:
	CACHE = {};

	// Number of freed buffers before cleaning the heap cache:
	LIMIT = 10000;

	// Freed buffer counter:
	COUNT = 0;

	// Create the wrapper:
	wrapper = Module.cwrap( 'stdlib_strided_dabs', null, [ 'number', 'number', 'number', 'number', 'number' ] );

	// Set methods:
	setReadOnly( dabs, 'malloc', malloc );
	setReadOnly( dabs, 'free', free );

	return dabs;

	/**
	* Cleans a heap cache, preventing the cache from continuously accumulating keys which no longer hold references to buffer objects.
	*
	* @private
	*/
	function cleanCache() {
		var keys;
		var key;
		var tmp;
		var i;

		keys = objectKeys( CACHE );

		// Note: we copy to a new object, rather than `delete` old keys, in order to ensure that the cache continues to have "fast" keys...
		tmp = {};
		for ( i = 0; i < keys.length; i++ ) {
			key = keys[ i ];
			if ( CACHE[ key ] !== null ) {
				tmp[ key ] = CACHE[ key ];
			}
		}
		CACHE = tmp;
		COUNT = 0;
	}

	/**
	* Allocates space on the heap.
	*
	* ## Notes
	*
	* -   This function provides guarded access to the module buffer. Otherwise, if the underlying buffer were directly exposed, users may be encouraged to modify buffer values outside their allotted space. By only returning a view, we encourage users to only modify values corresponding to that view.
	* -   The underlying buffer may still be obtained via `bytes.buffer`.
	*
	* @private
	* @param {PositiveInteger} nbytes - number of bytes to allocate
	* @returns {Uint8Array} bytes-view of the newly allocated buffer
	*
	* @example
	* var bytes = malloc( 10 );
	* // returns <Uint8Array>
	*/
	function malloc( nbytes ) {
		var byteOffset;
		var bytes;

		// Allocate space on the heap:
		byteOffset = Module._malloc( nbytes ); // eslint-disable-line no-underscore-dangle

		// Generate a bytes-wise view of the allocated buffer:
		bytes = new Uint8Array( Module.HEAPU8.buffer, byteOffset, nbytes );

		// Add methods for setting and getting buffer values:
		setReadOnly( bytes, 'getValue', getValue );
		setReadOnly( bytes, 'setValue', setValue );

		// Cache a reference to the buffer:
		CACHE[ byteOffset ] = bytes;

		return bytes;

		/**
		* Returns a value at a specific memory address.
		*
		* ## Notes
		*
		* -   The memory address is relative to the view, not the underlying buffer. The function handles mapping the view memory address to an underlying buffer memory address.
		*
		* @private
		* @param {NonNegativeInteger} ptr - memory address (number)
		* @param {string} [type="double"] - LLVM IR type ('i8', 'i16', 'i32', 'i64', 'float', 'double')
		* @returns {number} value
		*/
		function getValue( ptr, type ) {
			type = type || 'double';
			return Module.getValue( byteOffset+ptr, type );
		}

		/**
		* Sets a value at a specific memory address.
		*
		* ## Notes
		*
		* -   The memory address is relative to the view, not the underlying buffer. The function handles mapping the view memory address to an underlying buffer memory address.
		*
		* @private
		* @param {NonNegativeInteger} ptr - memory address (number)
		* @param {number} value to set
		* @param {string} [type="double"] - LLVM IR type ('i8', 'i16', 'i32', 'i64', 'float', 'double')
		*/
		function setValue( ptr, value, type ) {
			type = type || 'double';
			Module.setValue( byteOffset+ptr, value, type );
		}
	}

	/**
	* Frees space on the heap.
	*
	* ## Notes
	*
	* -   Calling this function repeatedly will incur a periodic performance hit in order to clear out old references to allocated buffers maintained in an internal cache. The performance hit can be avoided by judicious reuse of allocated buffers.
	*
	* @private
	* @param {Uint8Array} bytes - allocated buffer
	* @throws {Error} must provide an active heap buffer
	*
	* @example
	* // Allocate space:
	* var bytes = malloc( 10 );
	*
	* // Free allocated space:
	* free( bytes );
	*/
	function free( bytes ) {
		if ( CACHE[ bytes.byteOffset ] !== bytes ) {
			throw new Error( 'invalid argument. Unrecognized heap buffer. Either the heap buffer was already freed or the input value was not allocated and returned by `malloc`.' );
		}
		Module._free( bytes.byteOffset ); // eslint-disable-line no-underscore-dangle

		CACHE[ bytes.byteOffset ] = null;
		COUNT += 1;
		if ( COUNT === LIMIT ) {
			cleanCache();
		}
	}

	/**
	* Computes the absolute for each element in `x` and assigns the result to an element in `y`.
	*
	* @private
	* @param {PositiveInteger} N - number of elements
	* @param {Float64Array} bytesX - allocated heap buffer
	* @param {integer} strideX - `x` stride length
	* @param {Float64Array} bytesY - allocated destination heap buffer
	* @param {integer} strideY - `y` stride length
	* @throws {Error} must provide an active heap buffer
	* @returns {Float64Array} `ybytes`
	*
	* @example
	* var x = new Float64Array( [ -1.0, -2.0, -3.0, -4.0, -5.0 ] );
	* var y = new Float64Array( [ 0.0, 0.0, 0.0, 0.0, 0.0 ] );
	*
	* // Determine the number of bytes:
	* var nbytes = x.length * x.BYTES_PER_ELEMENT;
	*
	* // Allocate space on the heap:
	* var xbytes = dabs.malloc( nbytes );
	* var ybytes = dabs.malloc( nbytes );
	*
	* // Copy data to the heap:
	* xbytes.set( new Uint8Array( x.buffer ) );
	* ybytes.set( new Uint8Array( y.buffer ) );
	*
	* // Evaluate:
	* dabs( x.length, xbytes, 1, ybytes, 1 );
	*
	* // Extract the results from the heap:
	* var view = new Float64Array( ybytes.buffer, ybytes.byteOffset, y.length );
	* var i;
	* for ( i = 0; i < y.length; i++ ) {
	*     y[ i ] = view[ i ];
	* }
	* // y => <Float64Array>[ 1.0, 2.0, 3.0, 4.0, 5.0 ]
	*
	* // Free the memory:
	* dabs.free( xbytes );
	* dabs.free( ybytes );
	*/
	function dabs( N, bytesX, strideX, bytesY, strideY ) {
		if ( CACHE[ bytesX.byteOffset ] !== bytesX ) {
			throw new Error( 'invalid argument. Unrecognized `x` heap buffer. Either the heap buffer was already freed or the heap buffer input value was not allocated and returned by `malloc`.' );
		}
		if ( CACHE[ bytesY.byteOffset ] !== bytesY ) {
			throw new Error( 'invalid argument. Unrecognized `y` heap buffer. Either the heap buffer was already freed or the heap buffer input value was not allocated and returned by `malloc`.' );
		}
		wrapper( N, bytesX.byteOffset, strideX, bytesY.byteOffset, strideY );
		return bytesY;
	}
}


// EXPORTS //

module.exports = cwrap;
